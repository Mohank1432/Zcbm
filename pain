# ==========================================
# CONFIGURATION
# ==========================================
# Path to your list of IPs or Hostnames (one per line)
$InputFile  = "C:\Temp\ServerList.txt"

# Path where the result CSV will be saved
$OutputFile = "C:\Temp\Server_Health_Report.csv"

# Ports to check (comma separated). Example: "3389, 443, 80"
$PortsToTest = "3389, 443" 

# Timeout per port in milliseconds (1000ms = 1 second)
# Lower = Faster scanning of dead servers
$TimeoutMilliseconds = 1000  
# ==========================================


# --- 1. Validation & Setup ---
if (-not (Test-Path -Path $InputFile)) {
    Write-Error "STOPPING: Input file not found at: $InputFile"
    return
}

# Process Port String into Array
$portArray = $PortsToTest -split "," | ForEach-Object { $_.Trim() }

# Read Server List
$serverList = Get-Content -Path $InputFile
$totalServers = $serverList.Count
$results = [System.Collections.Generic.List[PSCustomObject]]::new()
$counter = 0

Write-Host "=============================================" -ForegroundColor Cyan
Write-Host " STARTING SERVER HEALTH CHECK" -ForegroundColor Cyan
Write-Host " Servers: $totalServers | Ports: $($portArray -join ', ')" -ForegroundColor Cyan
Write-Host "=============================================" -ForegroundColor Cyan

foreach ($server in $serverList) {
    $counter++
    $target = $server.Trim()
    
    # Skip empty lines
    if ([string]::IsNullOrWhiteSpace($target)) { continue }

    # Progress Bar
    $percentComplete = ($counter / $totalServers) * 100
    Write-Progress -Activity "Scanning Servers" -Status "Processing $target ($counter of $totalServers)" -PercentComplete $percentComplete

    # --- 2. DNS Resolution (Get both IP and Hostname) ---
    $resolvedHostname = "Not Resolved"
    $resolvedIP = "Not Resolved"
    $isIP = $target -match "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"

    try {
        $dnsEntry = [System.Net.Dns]::GetHostEntry($target)
        $resolvedHostname = $dnsEntry.HostName
        # Get the first IPv4 address
        $resolvedIP = ($dnsEntry.AddressList | Where-Object {$_.AddressFamily -eq 'InterNetwork'} | Select-Object -First 1).IPAddressToString
    }
    catch {
        # Fallback if DNS fails
        if ($isIP) { $resolvedIP = $target } else { $resolvedHostname = $target }
    }

    # --- 3. Ping Test & OS Detection ---
    $pingStatus = "Failed"
    $osEstimate = "Unknown"
    
    try {
        # We capture the full ping object to analyze TTL (Time To Live)
        $pingObj = Test-Connection -ComputerName $target -Count 1 -ErrorAction Stop
        
        if ($pingObj.Status -eq "Success" -or $pingObj.StatusCode -eq 0) {
            $pingStatus = "Success"
            
            # --- OS Logic based on TTL ---
            # Linux usually starts at 64, Windows at 128. 
            # Values decrease by 1 for every router hop.
            $ttl = $pingObj.ResponseTimeToLive
            
            if ($ttl -gt 0 -and $ttl -le 64) {
                $osEstimate = "Likely Linux (TTL:$ttl)"
            }
            elseif ($ttl -gt 64 -and $ttl -le 128) {
                $osEstimate = "Likely Windows (TTL:$ttl)"
            }
            else {
                $osEstimate = "Network Device/Other (TTL:$ttl)"
            }
        }
    }
    catch {
        # Ping failed, so we can't guess OS via TTL
        $osEstimate = "Unknown (No Ping)"
    }

    # --- 4. Port Loop ---
    foreach ($port in $portArray) {
        $portStatus = "Closed/Filtered"
        $notes = ""
        
        if ($pingStatus -eq "Failed") { $notes = "Ping Failed" }

        try {
            [int]$p = $port 
            
            # Use .NET TCP Client for fast custom timeout
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $connectTask = $tcpClient.ConnectAsync($target, $p)
            $wait = $connectTask.Wait($TimeoutMilliseconds)
            
            if ($wait -and $tcpClient.Connected) {
                $portStatus = "Open"
                $tcpClient.Close()
            }
        }
        catch {
            $notes = "$notes; Port Error: $($_.Exception.Message)"
        }
        finally {
            if ($tcpClient) { $tcpClient.Dispose() }
        }

        # --- 5. Create Result Object ---
        $resultObject = [PSCustomObject]@{
            Input_Source = $target
            Hostname     = $resolvedHostname
            IP_Address   = $resolvedIP
            OS_Estimate  = $osEstimate
            PingStatus   = $pingStatus
            TargetPort   = $port
            PortStatus   = $portStatus
            TimeStamp    = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Notes        = $notes.Trim('; ')
        }

        $results.Add($resultObject)
    }
}

# --- 6. Export Results ---
try {
    # Ensure output directory exists
    $outputDir = Split-Path -Path $OutputFile -Parent
    if (-not (Test-Path -Path $outputDir) -and -not [string]::IsNullOrEmpty($outputDir)) {
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    }

    $results | Export-Csv -Path $OutputFile -NoTypeInformation -Force
    Write-Host "Process Complete! Results saved to: $OutputFile" -ForegroundColor Green
}
catch {
    Write-Error "Failed to save CSV. Error: $($_.Exception.Message)"
}
